import discord
from discord.ext import commands
from discord import app_commands
import os
import io
import asyncio
import time
from dotenv import load_dotenv

load_dotenv()

# --- Configuration ---
TOKEN = os.getenv("DISCORD_TOKEN")
FREE_CHANNEL_ID = int(os.getenv("FREE_CHANNEL_ID") or 0)
PREMIUM_CHANNEL_ID = int(os.getenv("PREMIUM_CHANNEL_ID") or 0)
VOUCH_CHANNEL_ID = int(os.getenv("VOUCH_CHANNEL_ID") or 0)
STATUS_ROLE_ID = 1462753400050417755
TRIGGER_PHRASE = ".gg/9j7ew6UTrt :free mcfa gen"

STOCK_PATHS = {
    "free": {
        "minecraft": "free/minecraft.txt",
        "mc_bedrock": "free/mc_bedrock.txt"
    },
    "premium": {
        "Xbox": "premium/Xbox.txt",
        "Ranked": "premium/ranked.txt",
        "Banned": "premium/Banned.txt",
        "Unbanned": "premium/Unbanned.txt"
    }
}

class WinterCloudBot(commands.Bot):
    def __init__(self):
        intents = discord.Intents.all()
        super().__init__(command_prefix="!", intents=intents)
        self.gen_cooldowns = {}

    async def setup_hook(self):
        await self.tree.sync()
        print(f"Synced slash commands for {self.user}")

bot = WinterCloudBot()

# ==============================================================================
#                                UTILITY LOGIC
# ==============================================================================

async def process_gen(interaction: discord.Interaction, service: str, tier: str):
    # 1. DEFER IMMEDIATELY to prevent "Unknown Interaction" error
    await interaction.response.defer(ephemeral=True)
    
    user_id = interaction.user.id
    current_time = time.time()
    
    # Cooldown Check
    if user_id in bot.gen_cooldowns:
        remaining = bot.gen_cooldowns[user_id] - current_time
        if remaining > 0:
            minutes, seconds = divmod(int(remaining), 60)
            return await interaction.followup.send(
                f"‚è≥ **Cooldown active!** You can generate again in `{minutes}m {seconds}s`.", 
                ephemeral=True
            )

    path = STOCK_PATHS[tier].get(service)
    if not path or not os.path.exists(path) or os.path.getsize(path) == 0:
        return await interaction.followup.send(f"‚ùå **{service}** is currently out of stock!", ephemeral=True)

    try:
        with open(path, "r") as f:
            lines = f.readlines()
        
        if not lines:
            return await interaction.followup.send(f"‚ùå **{service}** is empty!", ephemeral=True)
            
        combo = lines[0].strip()
        with open(path, "w") as f:
            f.writelines(lines[1:])

        # Set 10-minute cooldown
        bot.gen_cooldowns[user_id] = current_time + 600

        email, password = combo.split(":", 1) if ":" in combo else (combo, "N/A")

        # DM Embed
        dm_embed = discord.Embed(color=0x7289da)
        dm_embed.description = (
            f"**:happy_panda: Your Generated Account Has Arrived!**\n\n"
            f"üéâ Thanks for generating from Winter Cloud! Here are your **{service.upper()}** credentials below:\n\n"
            f"**:mail: Email** \u200b \u200b \u200b \u200b \u200b \u200b \u200b \u200b \u200b **:password: Password**\n"
            f"`{email}` \u200b \u200b \u200b \u200b \u200b `{password}`\n\n"
            f"**:rt_villeger: Full Combo**\n"
            f"```\n{combo}\n```\n"
            f"‚ú® WinterCloud Services"
        )

        # Success Embed (Using followup because we deferred)
        success_embed = discord.Embed(color=0x2ecc71)
        success_embed.description = (
            f"**:green_dot: Account Generated Successfully!**\n\n"
            f"**:upload: Your account has been securely sent to your DMs. Please check your inbox!**\n\n"
            f"**:yellow_particles: New account generated by**\n{interaction.user.mention}\n\n"
            f"**:yellow_particles: Service generated**\n{tier.capitalize()} {service}\n\n"
            f"**:yellow_particles: Please vouch in**\n<#{VOUCH_CHANNEL_ID}> or else you will be tempbanned from the gen\n\n"
            f"Thanks for using WinterCloud Generator!"
        )

        try:
            await interaction.user.send(embed=dm_embed)
            await interaction.followup.send(embed=success_embed, ephemeral=True)
        except:
            await interaction.followup.send(f"‚ùå {interaction.user.mention}, I couldn't DM you! Please open your DMs.", ephemeral=True)
            
    except Exception as e:
        print(f"Error in process_gen: {e}")
        await interaction.followup.send("‚ùå An internal error occurred while processing your request.", ephemeral=True)

# ==============================================================================
#                                SLASH COMMANDS
# ==============================================================================

@bot.tree.command(name="free", description="Generate a free account (10m cooldown)")
@app_commands.describe(service="The service to generate")
@app_commands.choices(service=[
    app_commands.Choice(name="Minecraft", value="minecraft"),
    app_commands.Choice(name="MC Bedrock", value="mc_bedrock")
])
async def free_slash(interaction: discord.Interaction, service: app_commands.Choice[str]):
    if interaction.channel_id != FREE_CHANNEL_ID:
        return await interaction.response.send_message(f"‚ùå Use <#{FREE_CHANNEL_ID}>", ephemeral=True)
    await process_gen(interaction, service.value, "free")

@bot.tree.command(name="premium", description="Generate a premium account (10m cooldown)")
@app_commands.describe(service="The service to generate")
@app_commands.choices(service=[
    app_commands.Choice(name="Xbox", value="Xbox"),
    app_commands.Choice(name="Ranked", value="Ranked"),
    app_commands.Choice(name="Banned", value="Banned"),
    app_commands.Choice(name="Unbanned", value="Unbanned")
])
async def premium_slash(interaction: discord.Interaction, service: app_commands.Choice[str]):
    if interaction.channel_id != PREMIUM_CHANNEL_ID:
        return await interaction.response.send_message(f"‚ùå Use <#{PREMIUM_CHANNEL_ID}>", ephemeral=True)
    await process_gen(interaction, service.value, "premium")

@bot.tree.command(name="cstatus", description="Verify your custom status for the role")
async def cstatus_slash(interaction: discord.Interaction):
    # This command is fast, so we don't need defer, but we use a robust check
    member = interaction.guild.get_member(interaction.user.id) or await interaction.guild.fetch_member(interaction.user.id)
    
    status_text = ""
    for activity in member.activities:
        if isinstance(activity, discord.CustomActivity):
            if activity.name:
                status_text = str(activity.name).lower()
            break
    
    role = interaction.guild.get_role(STATUS_ROLE_ID)
    
    if TRIGGER_PHRASE.lower() in status_text:
        if role in member.roles:
            await interaction.response.send_message("‚úÖ You already have the role!", ephemeral=True)
        else:
            await member.add_roles(role)
            await interaction.response.send_message("‚úÖ Status verified! Role granted.", ephemeral=True)
    else:
        await interaction.response.send_message(
            f"‚ùå **Verification Failed!**\nMust include: `{TRIGGER_PHRASE}`\nDetected: `{status_text if status_text else 'No Custom Status Found'}`", 
            ephemeral=True
        )

@bot.tree.command(name="stock", description="Check current stock levels")
async def stock_slash(interaction: discord.Interaction):
    embed = discord.Embed(title="‚ùÑÔ∏è Winter Cloud Stock", color=0x3498db)
    for tier, items in STOCK_PATHS.items():
        val = ""
        for k, v in items.items():
            if os.path.exists(v):
                with open(v, "r") as f:
                    count = len(f.readlines())
            else:
                count = 0
            val += f"‚Ä¢ **{k}**: `{count}`\n"
        embed.add_field(name=tier.upper(), value=val or "Empty", inline=False)
    await interaction.response.send_message(embed=embed)

@bot.tree.command(name="restock", description="Admin Only: Upload accounts")
async def restock_slash(interaction: discord.Interaction, tier: str, category: str, file: discord.Attachment):
    if not interaction.user.guild_permissions.administrator:
        return await interaction.response.send_message("‚ùå Admin only!", ephemeral=True)
    
    tier = tier.lower()
    if tier not in STOCK_PATHS or category not in STOCK_PATHS[tier]:
        return await interaction.response.send_message("‚ùå Invalid tier/category.", ephemeral=True)

    content = (await file.read()).decode("utf-8").splitlines()
    accounts = [line.strip() for line in content if line.strip()]
    
    path = STOCK_PATHS[tier][category]
    with open(path, "a") as f:
        for acc in accounts: f.write(f"{acc}\n")

    await interaction.response.send_message(f"‚úÖ Added **{len(accounts)}** accounts.", ephemeral=True)

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user}")

bot.run(TOKEN)